const debug = require('debug');
const fetch = require('node-fetch');
const { URL, URLSearchParams } = require('url');
const crypto = require('crypto');

/**
 * Represents a UrBackup Server.
 */
class UrbackupServer {
  #url;
  #username;
  #password;
  #sessionId = '';
  #isLoggedIn = false;

  /**
   * @constructor
   * @param {string} url - Server's URL. Must include protocol, hostname and port (for example http://127.0.0.1:55414).
   * @param {string} username - Username used to log in. Anonymous login is used if empty or undefined.
   * @param {string} password - Password used to log in. Anonymous login is used if empty or undefined.
   */
  constructor (url, username = '', password = '') {
    this.#url = new URL(url);
    this.#url.pathname = 'x';
    this.#username = username;
    this.#password = password;
  }

  /**
   * Clears session ID and logged-in flag.
   */
  #clearLoginStatus () {
    this.#sessionId = '';
    this.#isLoggedIn = false;
  }

  /**
   * Makes API call to the server.
   * @param {string} action - Action.
   * @param {object} bodyParams - Action parameters.
   * @returns json response if successfull, Null otherwise.
   */
  async #fetchJson (action = '', bodyParams = {}) {
    this.#url.searchParams.set('a', action);

    if (this.#sessionId.length > 0) {
      bodyParams.ses = this.#sessionId;
    }

    const response = await fetch(this.#url, {
      method: 'POST',
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json; charset=UTF-8'
      },
      body: new URLSearchParams(bodyParams)
    }).catch((error) => {
      log('Connection failed');
      log(error.message);
    });

    if (response?.ok) {
      return response.json();
    } else {
      log(response);
      return null;
    }
  }

  /**
   * Hashes user password.
   * @param {string} storedSalt - PBKDF2 salt value as stored on the server.
   * @param {number} rounds - PBKDF2 iterations number.
   * @param {string} randomSalt - Random value generated by the server.
   * @returns string representation of password hash.
   */
  async #hashPassword (storedSalt, rounds, randomSalt) {
    function pbkdf2Async (password) {
      return new Promise((resolve, reject) => {
        crypto.pbkdf2(password, storedSalt, rounds, 32, 'sha256', (err, key) => {
          return err ? reject(err) : resolve(key);
        });
      });
    }

    let passwordHash = crypto.createHash('md5').update(storedSalt + this.#password, 'utf8').digest();

    if (rounds > 0) {
      const derivedKey = await pbkdf2Async(passwordHash);
      passwordHash = crypto.createHash('md5').update(randomSalt + derivedKey.toString('hex'), 'utf8').digest('hex');
    } else {
      passwordHash = crypto.createHash('md5').update(randomSalt + passwordHash, 'utf8').digest('hex');
    }

    return passwordHash;
  }

  /**
   * Logs in to the server. If username or password is undefined or empty then tries anonymous login.
   * @returns True if logged in successfully or was already logged in, False otherwise.
   */
  async #login () {
    if (this.#isLoggedIn === true && this.#sessionId.length > 0) {
      log('Already logged in');
      return true;
    }

    if (this.#username.length === 0 || this.#password.length === 0) {
      log('Trying anonymous login');
      const anonymousLoginResponse = await this.#fetchJson('login');

      if (anonymousLoginResponse?.success === true) {
        log('Anonymous login succeeded');
        this.#sessionId = anonymousLoginResponse.session;
        this.#isLoggedIn = true;
        return true;
      } else {
        log('Anonymous login failed');
        this.#clearLoginStatus();
        return false;
      }
    } else {
      const saltResponse = await this.#fetchJson('salt', { username: this.#username });

      if (saltResponse === null || typeof saltResponse?.salt === 'undefined') {
        log('Unable to get salt, invalid username');
        this.#clearLoginStatus();
        return false;
      } else {
        this.#sessionId = saltResponse.ses;
        const hashedPassword = await this.#hashPassword(saltResponse.salt, saltResponse.pbkdf2_rounds, saltResponse.rnd);

        log('Trying user login');
        const userLoginResponse = await this.#fetchJson('login', { username: this.#username, password: hashedPassword });

        if (userLoginResponse?.success === true) {
          log('User login succeeded');
          this.#isLoggedIn = true;
          return true;
        } else {
          log('User login failed, invalid password');
          this.#clearLoginStatus();
          return false;
        }
      }
    }
  }

  /**
   * Retrieves status.
   * @returns json if successfull, Null otherwise.
   */
  async getStatus () {
    const loginResponse = await this.#login();

    if (loginResponse !== true) {
      return null;
    } else {
      const statusResponse = await this.#fetchJson('status');

      if (statusResponse === null || typeof statusResponse?.status === 'undefined') {
        return null;
      } else {
        return statusResponse.status;
      }
    }
  }

  /**
   * Retrieves general settings.
   * @returns json if successfull, Null otherwise.
   */
  async getGeneralSettings () {
    const loginResponse = await this.#login();

    if (loginResponse !== true) {
      return null;
    } else {
      const statusResponse = await this.#fetchJson('settings', { sa: 'general' });

      if (statusResponse === null || typeof statusResponse?.settings === 'undefined') {
        return null;
      } else {
        return statusResponse.settings;
      }
    }
  }

  /**
   * Retrieves server's identity.
   * @returns string if successfull, Null otherwise.
   */
  async getServerIdentity () {
    const loginResponse = await this.#login();

    if (loginResponse !== true) {
      return null;
    } else {
      const statusResponse = await this.#fetchJson('status');

      if (statusResponse === null || typeof statusResponse?.server_identity === 'undefined') {
        return null;
      } else {
        return statusResponse.server_identity.toString();
      }
    }
  }

  /**
   * Retrieves a list of users.
   * @returns array if successfull, Null otherwise.
   */
  async getUsers () {
    const loginResponse = await this.#login();

    if (loginResponse !== true) {
      return null;
    } else {
      const statusResponse = await this.#fetchJson('settings', { sa: 'listusers' });

      if (statusResponse === null || typeof statusResponse?.users === 'undefined') {
        return null;
      } else {
        return statusResponse.users;
      }
    }
  }

  /**
   * Retrieves storage usage grouped by client.
   * @returns array if successfull, Null otherwise.
   */
  async getUsage () {
    const loginResponse = await this.#login();

    if (loginResponse !== true) {
      return null;
    } else {
      const statusResponse = await this.#fetchJson('usage');

      if (statusResponse === null || typeof statusResponse?.usage === 'undefined') {
        return null;
      } else {
        return statusResponse.usage;
      }
    }
  }

  /**
   * Retrieves storage usage of specified client.
   * @param {string} clientName - Client's name, case sensitive.
   * @returns json if successfull, Null otherwise.
   */
  async getClientUsage (clientName = '') {
    const loginResponse = await this.#login();

    if (loginResponse !== true) {
      return null;
    } else {
      const statusResponse = await this.#fetchJson('usage');

      if (statusResponse === null || typeof statusResponse?.usage === 'undefined') {
        return null;
      } else {
        const clientUsage = statusResponse.usage.find(client => client.name === clientName);
        if (typeof clientUsage === 'undefined') {
          log('Failed to find client usage: no permission or client not found');
          return null;
        } else {
          return clientUsage;
        }
      }
    }
  }
}

const log = debug('app:log');
log.log = console.log.bind(console);

module.exports.UrbackupServer = UrbackupServer;
